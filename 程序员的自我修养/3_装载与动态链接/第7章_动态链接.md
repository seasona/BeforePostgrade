<!-- TOC -->

- [地址无关代码](#地址无关代码)
    - [链接重定位和装载重定位](#链接重定位和装载重定位)

<!-- /TOC -->

### 地址无关代码
动态链接中会出现模块加载地址重叠，比如进程1依赖于模块A、B，进程2依赖于模块C、D。此时单独使用进程1或2，就算重叠了也没有问题，但是如果进程3依赖于A、B、C、D，此时进程3根本无法运行，因为模块间地址重叠。就算手动管理地址将ABCD对应的地址都分开，但是单独使用进程1的时候也要保留CD对应的地址，非常浪费内存
#### 链接重定位和装载重定位
链接重定位其实主要是生成一个重定位表来保存需要重定位的符号以及重定位入口在段内的偏移
装载重定位就是实际分配物理地址时，根据所有绝对地址引用进行重定位，比如函数foo()相对于代码段的起始地址是0x100，那么当模块被装载到0x100000后，被重定位至0x100100
装载重定位不适合解决地址无关问题，因为指令部分是在多个进程之间共享的，但是装载时重定位需要修改指令对应地址，所以无法同一份指令被多个进程共享。而动态链接库中的可修改数据部分对于不同进程来说有多个副本，所以它们可以采用装载时重定位的方法来解决
而gcc中就可以使用-fPIC，把指令部分需要修改的部分分离出来，放在数据部分，这样指令部分就可以不变，而数据部分就可以在每个进程中拥有一个副本，这种方案就被称为地址无关代码(PIC)技术